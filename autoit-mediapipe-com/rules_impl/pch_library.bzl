load(":rules_impl/cc_object.bzl", "cc_object")

# https://github.com/bazelbuild/bazel-skylib/blob/1.7.1/rules/private/write_file_private.bzl#L21-L43
def _write_pch_header_impl(ctx):
    hdr_file = ctx.actions.declare_file(ctx.attr.out + ".hxx")

    hdr_content = "/* Generated by Bazel pch_library */\n\n#pragma system_header\n#ifdef __cplusplus"
    for hdr in ctx.files.hdrs:
        hdr_content = hdr_content + "\n#include \"" + hdr.path + "\""
    hdr_content = hdr_content + "\n#endif // __cplusplus\n"

    ctx.actions.write(
        output = hdr_file,
        content = hdr_content,
    )

    files = depset(direct = [hdr_file])
    runfiles = ctx.runfiles(files = [hdr_file])

    # Do not include the copied file into the default runfiles of the
    # target, but ensure that it is picked up by native rule's data
    # attribute despite https://github.com/bazelbuild/bazel/issues/15043.
    return [DefaultInfo(files = files, data_runfiles = runfiles)]

write_pch_header = rule(
    implementation = _write_pch_header_impl,
    provides = [DefaultInfo],
    attrs = {
        "hdrs": attr.label_list(allow_files = True),
        "out": attr.string(mandatory = True),
    },
    output_to_genfiles = True,
)

# https://github.com/bazelbuild/bazel-skylib/blob/1.7.1/rules/private/copy_common.bzl#L17-L45
# Hints for Bazel spawn strategy
COPY_EXECUTION_REQUIREMENTS = {
    # ----------------+-----------------------------------------------------------------------------
    # no-remote       | Prevents the action or test from being executed remotely or cached remotely.
    #                 | This is equivalent to using both `no-remote-cache` and `no-remote-exec`.
    # ----------------+-----------------------------------------------------------------------------
    # no-cache        | Results in the action or test never being cached (remotely or locally)
    # ----------------+-----------------------------------------------------------------------------
    # See https://bazel.build/reference/be/common-definitions#common-attributes
    #
    # Copying file & directories is entirely IO-bound and there is no point doing this work
    # remotely.
    #
    # Also, remote-execution does not allow source directory inputs, see
    # https://github.com/bazelbuild/bazel/commit/c64421bc35214f0414e4f4226cc953e8c55fa0d2 So we must
    # not attempt to execute remotely in that case.
    #
    # There is also no point pulling the output file or directory from the remote cache since the
    # bytes to copy are already available locally. Conversely, no point in writing to the cache if
    # no one has any reason to check it for this action.
    #
    # Read and writing to disk cache is disabled as well primarily to reduce disk usage on the local
    # machine. A disk cache hit of a directory copy could be slghtly faster than a copy since the
    # disk cache stores the directory artifact as a single entry, but the slight performance bump
    # comes at the cost of heavy disk cache usage, which is an unmanaged directory that grow beyond
    # the bounds of the physical disk.
    "no-remote": "1",
    "no-cache": "1",
}

# https://github.com/bazelbuild/bazel-skylib/blob/1.7.1/rules/private/copy_file_private.bzl#L24-L50
def copy_cmd(ctx, src, dst):
    # Most Windows binaries built with MSVC use a certain argument quoting
    # scheme. Bazel uses that scheme too to quote arguments. However,
    # cmd.exe uses different semantics, so Bazel's quoting is wrong here.
    # To fix that we write the command to a .bat file so no command line
    # quoting or escaping is required.
    bat = ctx.actions.declare_file(ctx.label.name + "-cmd.bat")
    ctx.actions.write(
        output = bat,
        # Do not use lib/shell.bzl's shell.quote() method, because that uses
        # Bash quoting syntax, which is different from cmd.exe's syntax.
        content = "@copy /Y \"%s\" \"%s\" >NUL" % (
            src.path.replace("/", "\\"),
            dst.path.replace("/", "\\"),
        ),
        is_executable = True,
    )
    ctx.actions.run(
        inputs = [src, bat],
        outputs = [dst],
        executable = "cmd.exe",
        arguments = ["/C", bat.path.replace("/", "\\")],
        mnemonic = "CopyFile",
        progress_message = "Copying files",
        use_default_shell_env = True,
        execution_requirements = COPY_EXECUTION_REQUIREMENTS,
    )

# https://github.com/bazelbuild/bazel-skylib/blob/1.7.1/rules/private/copy_file_private.bzl#L52-L62
def copy_bash(ctx, src, dst):
    ctx.actions.run_shell(
        inputs = [src],
        outputs = [dst],
        command = "cp -f \"$1\" \"$2\"",
        arguments = [src.path, dst.path],
        mnemonic = "CopyFile",
        progress_message = "Copying files",
        use_default_shell_env = True,
        execution_requirements = COPY_EXECUTION_REQUIREMENTS,
    )

# https://github.com/bazelbuild/bazel-skylib/blob/1.7.1/rules/private/write_file_private.bzl#L29-L43
def _write_pch_cc_file_impl(ctx):
    if ctx.attr.is_windows:
        suffix = ".cxx"
    else:
        suffix = ".hxx.cxx"

    src_file = ctx.actions.declare_file(ctx.attr.out + suffix)

    ctx.actions.write(
        content = "/* Generated by Bazel pch_library */",
        output = src_file,
    )

    files = depset(direct = [src_file])
    runfiles = ctx.runfiles(files = [src_file])

    # Do not include the copied file into the default runfiles of the
    # target, but ensure that it is picked up by native rule's data
    # attribute despite https://github.com/bazelbuild/bazel/issues/15043.
    return [DefaultInfo(files = files, data_runfiles = runfiles)]

# https://github.com/bazelbuild/bazel-skylib/blob/1.7.1/rules/private/write_file_private.bzl#L51-L56
write_pch_cc_file = rule(
    implementation = _write_pch_cc_file_impl,
    provides = [DefaultInfo],
    attrs = {
        "src": attr.label(mandatory = True, allow_single_file = True),
        "out": attr.string(mandatory = True),
        "allow_symlink": attr.bool(default = False),
        "is_windows": attr.bool(default = False),
        "host_is_windows": attr.bool(default = False),
    },
    output_to_genfiles = True,
)

# https://github.com/bazelbuild/bazel-skylib/blob/1.7.1/rules/private/write_file_private.bzl#L64-L84
def _copy_unix_pch_object_impl(ctx):    
    obj_file = ctx.actions.declare_file(ctx.attr.out + ".hxx.gch")

    if ctx.attr.is_windows:
        copy_cmd(ctx, ctx.file.src, obj_file)
    elif ctx.attr.allow_symlink:
        ctx.actions.symlink(
            output = obj_file,
            target_file = ctx.file.src,
        )
    else:
        copy_bash(ctx, ctx.file.src, obj_file)

    files = depset(direct = [obj_file] + ctx.attr.src[DefaultInfo].files.to_list())
    runfiles = ctx.runfiles(files = [obj_file] + ctx.attr.src[DefaultInfo].data_runfiles.files.to_list())

    # Do not include the copied file into the default runfiles of the
    # target, but ensure that it is picked up by native rule's data
    # attribute despite https://github.com/bazelbuild/bazel/issues/15043.
    return [
        DefaultInfo(files = files, data_runfiles = runfiles),
        ctx.attr.src[CcInfo],
    ]

# https://github.com/bazelbuild/bazel-skylib/blob/1.7.1/rules/private/write_file_private.bzl#L86-L92
copy_unix_pch_object = rule(
    implementation = _copy_unix_pch_object_impl,
    attrs = {
        "src": attr.label(
            mandatory = True,
            allow_single_file = True,
            providers = [CcInfo],
        ),
        "out": attr.string(mandatory = True),
        "allow_symlink": attr.bool(default = False),
        "is_windows": attr.bool(default = False),
        "host_is_windows": attr.bool(default = False),
    },
    provides = [CcInfo],
    output_to_genfiles = True,
)

def _pch_library_rule_impl(ctx):
    return [
        ctx.attr.src[DefaultInfo],
        ctx.attr.src[CcInfo],
    ]

pch_library_rule = rule(
    implementation = _pch_library_rule_impl,
    attrs = {
        "src": attr.label(mandatory = True, providers = [CcInfo]),
    },
    provides = [CcInfo],
)

def pch_library(name, **kwargs):
    pch = "_pch_" + name
    hdrs = kwargs["hdrs"]
    kwargs.pop("hdrs", None)

    pch_header = pch + "_header"
    write_pch_header(
        name = pch_header,
        hdrs = hdrs,
        out = pch,
    )

    pch_cc = pch + "_cc"
    write_pch_cc_file(
        name = pch_cc,
        src = ":" + pch_header,
        out = pch,
        is_windows = select({
            "@bazel_tools//src/conditions:host_windows": True,
            "//conditions:default": False,
        }),
    )

    kwargs["copts"] = kwargs.get("copts", []) + select({
        "@bazel_tools//src/conditions:windows": [
            "/FI$(location :" + pch_header + ")",
            "/Yc$(location :" + pch_header + ")",
        ],
        "//conditions:default": ["-Winvalid-pch", "-x", "c++-header", "-include", "$(location :" + pch_header + ")"],
    })

    pch_copts = select({
        "@bazel_tools//src/conditions:windows": [
            "/FI$(location :" + pch_header + ")",
            "/Yu$(location :" + pch_header + ")",
        ],
        "//conditions:default": ["-Winvalid-pch", "-include", "$(location :" + pch_header + ")"],
    })

    pch_object = pch + "_object"
    cc_object(
        name = pch_object,
        srcs = [":" + pch_header, ":" + pch_cc],
        hdrs = hdrs,
        **kwargs
    )

    pch_object_unix = pch + "_object_unix"
    copy_unix_pch_object(
        name = pch_object_unix,
        src = ":" + pch_object,
        out = pch,
        allow_symlink = True,
        is_windows = select({
            "@bazel_tools//src/conditions:host_windows": True,
            "//conditions:default": False,
        }),
    )

    pch_library_rule(
        name = pch,
        src = select({
            "@bazel_tools//src/conditions:windows": ":" + pch_object,
            "//conditions:default": ":" + pch_object_unix,
        }),
    )

    return {
        # needed to link to the precompiled header
        "srcs": select({
            "@bazel_tools//src/conditions:windows": [":" + pch],
            "//conditions:default": [],
        }),

        # Needed to compile with the precompiled header
        "copts": pch_copts,

        # Needed for $(location ) substitution when compiling with the precompiled header file
        "data": [":" + pch_header],

        # Needed to make pch files available to C++ compilation targets
        "additional_compiler_inputs": select({
            "@bazel_tools//src/conditions:windows": [":" + pch_object],
            "//conditions:default": [":" + pch_object_unix],
        }),
    }
